name: Stremio Web Server with Ngrok

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches: [ main ]  # Or your preferred branch

jobs:
  stremio-server:
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        # Don't cache here since package files are in subdirectory

    - name: Install Chocolatey packages
      run: |
        choco install wget -y
        choco install unzip -y
      shell: powershell

    - name: Download and setup ngrok
      run: |
        # Download ngrok for Windows
        Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile "ngrok.zip"
        
        # Extract ngrok
        Expand-Archive -Path "ngrok.zip" -DestinationPath "." -Force
        
        # Add ngrok to PATH
        echo "$pwd" | Out-File -Append -FilePath $env:GITHUB_PATH -Encoding utf8
        
        # Verify ngrok installation
        ./ngrok version
      shell: powershell

    - name: Configure ngrok authentication
      env:
        NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
      run: |
        ./ngrok config add-authtoken $env:NGROK_AUTH_TOKEN
      shell: powershell

    - name: Clone and setup Stremio Web
      run: |
        # Clone the Stremio Web repository
        git clone https://github.com/Stremio/stremio-web.git
        cd stremio-web
        
        # Install dependencies with proper error handling
        npm ci --prefer-offline --no-audit
        
        # Build the project
        npm run build
      shell: powershell

    - name: Start Stremio server in background
      run: |
        # Start the Stremio web server in the background
        cd stremio-web
        $job = Start-Job -ScriptBlock {
          param($path)
          Set-Location $path
          npm start
        } -ArgumentList (Get-Location).Path
        
        # Wait for the server to start
        Start-Sleep -Seconds 15
        
        # Check if server is running on common ports
        $ports = @(8080, 3000, 8081, 11470)
        $serverPort = $null
        
        foreach ($port in $ports) {
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:$port" -UseBasicParsing -TimeoutSec 5 -ErrorAction Stop
            Write-Host "‚úÖ Stremio server is running on port $port"
            $serverPort = $port
            break
          } catch {
            Write-Host "Port $port not responding, trying next..."
          }
        }
        
        if (-not $serverPort) {
          Write-Host "‚ùå Could not detect server port. Server might need more time to start."
          $serverPort = 11470  # Default Stremio port
        }
        
        # Save job ID and port for later reference
        $job.Id | Out-File -FilePath "server_job_id.txt"
        $serverPort | Out-File -FilePath "server_port.txt"
      shell: powershell

    - name: Start ngrok tunnel
      run: |
        # Get the server port
        $serverPort = if (Test-Path "server_port.txt") { 
          Get-Content "server_port.txt" 
        } else { 
          11470 
        }
        
        Write-Host "Starting ngrok tunnel for port $serverPort"
        
        # Start ngrok tunnel in the background
        $ngrokJob = Start-Job -ScriptBlock {
          param($path, $port)
          Set-Location $path
          ./ngrok http $port --log-level=info --log=stdout
        } -ArgumentList (Get-Location).Path, $serverPort
        
        # Wait for ngrok to establish connection
        Start-Sleep -Seconds 8
        
        # Get ngrok public URL using API
        $maxRetries = 5
        $retry = 0
        $publicUrl = $null
        
        while ($retry -lt $maxRetries -and -not $publicUrl) {
          try {
            $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -Method Get -TimeoutSec 10
            if ($response.tunnels -and $response.tunnels.Count -gt 0) {
              $publicUrl = $response.tunnels[0].public_url
            }
          } catch {
            $retry++
            Write-Host "Retry $retry/$maxRetries - waiting for ngrok..."
            Start-Sleep -Seconds 3
          }
        }
        
        if ($publicUrl) {
          Write-Host "================================================"
          Write-Host "üé¨ Stremio Web Server is now accessible at:"
          Write-Host "üìç $publicUrl"
          Write-Host "================================================"
          
          # Save URL to file and environment variable
          $publicUrl | Out-File -FilePath "ngrok_url.txt"
          echo "STREMIO_URL=$publicUrl" | Out-File -Append -FilePath $env:GITHUB_ENV -Encoding utf8
          
          # Output as GitHub Action notice
          echo "::notice title=Stremio Server URL::$publicUrl"
        } else {
          Write-Host "‚ùå Could not retrieve ngrok URL automatically"
          Write-Host "Check ngrok dashboard at: https://dashboard.ngrok.com/endpoints/status"
        }
        
        # Save ngrok job ID
        $ngrokJob.Id | Out-File -FilePath "ngrok_job_id.txt"
      shell: powershell

    # Rest of your workflow steps remain the same...
    - name: Display connection information
      run: |
        Write-Host "================================"
        Write-Host "üì∫ STREMIO WEB SERVER STATUS"
        Write-Host "================================"
        
        if (Test-Path "ngrok_url.txt") {
          $url = Get-Content "ngrok_url.txt"
          Write-Host "‚úÖ Public URL: $url"
          Write-Host ""
          Write-Host "You can now access your Stremio server from anywhere!"
          Write-Host "The server will remain active for the duration of this workflow run."
        } else {
          Write-Host "‚ö†Ô∏è Could not retrieve public URL automatically."
          Write-Host "Check your ngrok dashboard for the tunnel URL."
        }
        
        Write-Host ""
        Write-Host "üìù Notes:"
        Write-Host "- The free ngrok tier has limitations (1 concurrent tunnel, limited requests)"
        Write-Host "- This session will timeout based on your GitHub Actions runner limits"
        Write-Host "- Consider using ngrok paid tier for production use"
      shell: powershell

    - name: Keep server running
      run: |
        Write-Host "Server is running. Keeping the workflow active for 6 hours or until cancelled..."
        Write-Host "Press Ctrl+C in the GitHub Actions log to stop the server."
        
        # Keep the workflow running for 6 hours (GitHub Actions max)
        $timeout = 6 * 60 * 60  # 6 hours in seconds
        $elapsed = 0
        $interval = 30  # Check every 30 seconds
        
        while ($elapsed -lt $timeout) {
          Start-Sleep -Seconds $interval
          $elapsed += $interval
          
          # Periodically output status to avoid GitHub Actions timeout
          if ($elapsed % 300 -eq 0) {  # Every 5 minutes
            $minutes = $elapsed / 60
            Write-Host "‚è±Ô∏è Server has been running for $minutes minutes..."
            
            # Check if services are still running
            if (Test-Path "ngrok_url.txt") {
              $url = Get-Content "ngrok_url.txt"
              Write-Host "üìç Still accessible at: $url"
            }
          }
        }
        
        Write-Host "‚è∞ Maximum runtime reached. Shutting down..."
      shell: powershell
      timeout-minutes: 360  # 6 hours

    - name: Cleanup on failure or completion
      if: always()
      run: |
        Write-Host "Cleaning up processes..."
        
        # Stop the server job if it exists
        if (Test-Path "server_job_id.txt") {
          $jobId = Get-Content "server_job_id.txt"
          Stop-Job -Id $jobId -ErrorAction SilentlyContinue
          Remove-Job -Id $jobId -ErrorAction SilentlyContinue
        }
        
        # Stop the ngrok job if it exists
        if (Test-Path "ngrok_job_id.txt") {
          $jobId = Get-Content "ngrok_job_id.txt"
          Stop-Job -Id $jobId -ErrorAction SilentlyContinue
          Remove-Job -Id $jobId -ErrorAction SilentlyContinue
        }
        
        # Kill any remaining node or ngrok processes
        Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
        Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
        
        Write-Host "Cleanup completed."
      shell: powershell
